#!/usr/bin/env bash

# use exit codes of failing commands
set -exo pipefail

# Set non-interactive frontend to avoid prompts during package installation
export DEBIAN_FRONTEND=noninteractive

SOURCES=${SOURCES-/sources}
OUTPUT=${OUTPUT-${SOURCES}}

# Initialize default values for options and flags
FORCE=false
ENABLE_REPOS=""
EXTERNAL_BUILD_SCRIPT=""
NO_FETCH=false

# Store original arguments for checking --no-fetch
ORIGINAL_ARGS="$*"

# Loop through the arguments
while [[ "$1" != "" ]]; do
    case $1 in
        --force )
            FORCE=true
            ;;
        --enable-repos )
            shift # Move to the next argument, which should be the value for --option
            if [[ -n $1 ]]; then
                ENABLE_REPOS=$1
            else
                echo "Error: --enable-repos requires a value."
                exit 1
            fi
            ;;
        --external-build-script )
            shift # Move to the next argument, which should be the URL
            if [[ -n $1 ]]; then
                EXTERNAL_BUILD_SCRIPT=$1
            else
                echo "Error: --external-build-script requires a URL."
                exit 1
            fi
            ;;
        --no-fetch )
            NO_FETCH=true
            ;;
        * )
            echo "Invalid option: $1"
            exit 1
            ;;
    esac
    shift # Move to the next argument
done

# If external build script is specified, fetch and use it
if [[ -n "${EXTERNAL_BUILD_SCRIPT}" ]]; then
    echo "Fetching external build script from: ${EXTERNAL_BUILD_SCRIPT}"
    if curl -fsSL "${EXTERNAL_BUILD_SCRIPT}" > /tmp/external-build.sh; then
        chmod +x /tmp/external-build.sh
        exec /tmp/external-build.sh "$@"
    else
        echo "Failed to fetch external build script. Falling back to built-in script."
    fi
fi

# Try to fetch and execute the latest build script from GitHub
# This allows getting the latest build logic without rebuilding Docker images
# We add --no-fetch to prevent infinite recursion
if [[ "$NO_FETCH" != "true" ]]; then
    echo "Attempting to fetch latest build script from GitHub..."
    # Add cache busting to prevent GitHub from serving cached versions
    cache_buster=$(date +%s)
    if curl -fsSL "https://raw.githubusercontent.com/GetPageSpeed/debbuilder/refs/heads/main/assets/build?${cache_buster}" > /tmp/latest-build.sh; then
        chmod +x /tmp/latest-build.sh
        echo "Successfully fetched latest build script. Executing..."
        exec /tmp/latest-build.sh --no-fetch "$@"
    else
        echo "Failed to fetch latest build script. Using local version."
    fi
fi

# Enable additional repositories if needed
if [[ -n ${ENABLE_REPOS} ]]; then
  add-apt-repository "${ENABLE_REPOS}" || exit 1
  apt-get update
fi

# Look for all subdirectories containing a `debian` directory
find_packages() {
    find "${SOURCES}" -mindepth 1 -type d -name debian -exec dirname {} \;
}

# Function to check if the package can be skipped
check_packages_in_repo() {
    local source_dir=$1
    cd "$source_dir"
    if [[ -f "debian/control" ]]; then
        # Parse the package name and version
        package_name=$(dpkg-parsechangelog --show-field Source)
        package_version=$(dpkg-parsechangelog --show-field Version)

        # Check if package already exists in repository
        if apt-cache show "${package_name}=${package_version}" &>/dev/null; then
            echo "Package ${package_name} version ${package_version} already exists. Skipping build."
            return 0
        else
            echo "Package ${package_name} version ${package_version} is missing. Building it."
            return 1
        fi
    else
        echo "No debian/control file found in ${source_dir}. Skipping build."
        return 0
    fi
}

# Build the debian package
build_package() {
    local source_dir=$1
    echo "Building package from directory: ${source_dir}"
    echo "Current directory before cd: $(pwd)"
    cd "$source_dir"
    echo "Current directory after cd: $(pwd)"

    if [ "$FORCE" = true ]; then
        echo "Building package without checking repository because --force is set"
    elif check_packages_in_repo "${source_dir}"; then
        echo "Skipping build for ${source_dir}."
        return 0
    fi

    # Use upstream.yml (required) for fetching sources
    if [[ -f "upstream.yml" ]]; then
        echo "Found upstream.yml; using it for upstream source resolution..."
        # Determine package name early
            PACKAGE=""
            if [[ -f "debian/control" ]]; then
            PACKAGE=$(awk '/^Source:/{print $2; exit}' debian/control || true)
            fi
            if [[ -z "${PACKAGE}" ]]; then
                PACKAGE=$(basename "$(pwd)")
            fi
        # Parse version and source template (support quoted or unquoted values)
        VERSION="$(awk -F\" '/^version:[[:space:]]*\"/{print $2; exit} /^version:[[:space:]]*[0-9]/{gsub(/^version:[[:space:]]*/,""); print; exit}' upstream.yml || true)"
        TEMPLATE="$(awk -F\" '/^source:[[:space:]]*\"/{print $2; exit} /^source:[[:space:]]*[^#]/{sub(/^source:[[:space:]]*/,""); gsub(/[[:space:]]+#.*/,""); print; exit}' upstream.yml || true)"
        if [[ -z "${VERSION}" ]] || [[ -z "${TEMPLATE}" ]]; then
            echo "Error: upstream.yml must define both version and source"
                        return 1
        fi
        # Build final URL (support {version} and optional {name})
        URL="${TEMPLATE//\{version\}/${VERSION}}"
        if printf '%s' "${URL}" | grep -q '{name}'; then
            URL="${URL//\{name\}/${PACKAGE}}"
        fi
        echo "Resolved source URL: ${URL}"
        # Skip download if already prepared
        if [[ -d "${PACKAGE}-${VERSION}" ]]; then
            echo "Source directory ${PACKAGE}-${VERSION} already present; skipping download."
        else
            FILENAME="$(basename "${URL}")"
            echo "Downloading ${FILENAME}..."
            if curl -fsSL -o "${FILENAME}" "${URL}"; then
                echo "Extracting ${FILENAME}..."
                tar -xf "${FILENAME}"
                # Detect top-level directory name from tar
                TOPDIR="$(tar -tf "${FILENAME}" | head -1 | cut -d/ -f1)"
                if [[ -n "${TOPDIR}" ]] && [[ -d "${TOPDIR}" ]]; then
                    # Normalize nested layout like nginx-X/nginx-X/*
                    if [[ -d "${TOPDIR}/${TOPDIR}" ]]; then
                        mv "${TOPDIR}/${TOPDIR}"/* "${TOPDIR}/"
                        rmdir "${TOPDIR}/${TOPDIR}" || true
                    fi
                    # If packaging is outside, copy it in
                    if [[ -d "debian" ]] && [[ ! -d "${TOPDIR}/debian" ]]; then
                        cp -r debian "${TOPDIR}/"
                    fi
                fi
            else
                echo "Error: failed to download ${URL}"
                return 1
            fi
        fi
    else
        echo "Error: upstream.yml not found. This builder requires upstream.yml with 'version' and 'source'."
        return 1
    fi
    
    # After setup.sh, we need to find where the source code and debian directory are
    # The setup.sh script might have created a subdirectory structure
    if [[ -d "debian" ]]; then
        echo "Found debian directory in current location"
        DEBIAN_DIR="."
    else
        # Look for debian directory in subdirectories
        DEBIAN_DIR=$(find . -name "debian" -type d | head -1 | xargs dirname)
        if [[ -n "${DEBIAN_DIR}" ]]; then
            echo "Found debian directory in: ${DEBIAN_DIR}"
            cd "${DEBIAN_DIR}"
        else
            # If no debian directory found, check if we're in a subdirectory that was created by setup.sh
            # Look for setup.py or other build files to determine if this is the source directory
            if [[ -f "setup.py" ]] || [[ -f "pyproject.toml" ]] || [[ -f "Makefile" ]]; then
                echo "Found source directory with build files in current location"
                DEBIAN_DIR="."
            else
                echo "Error: No debian directory or source files found after setup.sh"
                echo "Current directory contents:"
                ls -la
                echo "Looking for debian directories:"
                find . -name "debian" -type d 2>/dev/null || echo "No debian directories found"
                return 1
            fi
        fi
    fi
    
    # Check if we need to find the source code in a subdirectory
    # This handles cases where the debian directory is in the parent but source is in a subdirectory
    if [[ ! -f "setup.py" ]] && [[ ! -f "pyproject.toml" ]] && [[ ! -f "Makefile" ]]; then
        echo "No build files found in current directory, looking for source in subdirectories..."
        SOURCE_DIR=$(find . -name "setup.py" -o -name "pyproject.toml" -o -name "Makefile" | head -1 | xargs dirname)
        if [[ -n "${SOURCE_DIR}" ]]; then
            echo "Found source directory: ${SOURCE_DIR}"
            cd "${SOURCE_DIR}"
            echo "Changed to source directory: $(pwd)"
        else
            echo "No source files found in subdirectories"
            echo "Available files:"
            find . -type f -name "setup.py" -o -name "pyproject.toml" -o -name "Makefile" 2>/dev/null || echo "No build files found"
        fi
    fi

    # Check for version and update changelog (read only from upstream.yml)
    if [[ -z "${VERSION}" ]] && [[ -f "upstream.yml" ]]; then
        VERSION="$(awk -F\" '/^version:[[:space:]]*\"/{print $2; exit} /^version:[[:space:]]*[0-9]/{gsub(/^version:[[:space:]]*/,""); print; exit}' upstream.yml || true)"
    fi

    if [[ -n "${VERSION}" ]]; then
        echo "Updating version references with version ${VERSION} and distribution ${DISTRO}..."
        # Update changelog if it exists
        if [[ -f "debian/changelog" ]]; then
            sed -i "s/VERSION/${VERSION}/g" debian/changelog
            sed -i "s/DISTRO/${DISTRO}/g" debian/changelog || true
            echo "Updated debian/changelog"
        fi
        # Update any other files that might contain version references
        for file in debian/*; do
            if [[ -f "$file" ]]; then
                if grep -q "VERSION" "$file"; then
                    sed -i "s/VERSION/${VERSION}/g" "$file"
                    echo "Updated version references in $file"
                fi
                if grep -q "DISTRO" "$file"; then
                    sed -i "s/DISTRO/${DISTRO}/g" "$file"
                    echo "Updated distribution references in $file"
                fi
            fi
        done
        for file in *.py *.txt *.md *.rst; do
            if [[ -f "$file" ]]; then
                if grep -q "VERSION" "$file"; then
                    sed -i "s/VERSION/${VERSION}/g" "$file"
                    echo "Updated version references in $file"
                fi
            fi
        done
    else
        echo "Warning: No version found in rpmmacros/debmacros; using existing changelog version."
    fi

    # Clean up old build artifacts
    if [[ -f "debian/rules" ]]; then
        make -f debian/rules clean || dh clean || true
    fi

    # Install build dependencies from the current directory (which should have debian/control)
    echo "Installing build dependencies from $(pwd)..."

    # Ensure package lists are up to date
    echo "Updating package lists..."
    if ! apt-get update; then
        echo "Warning: Failed to update package lists, attempting to fix repository configuration..."
        # Universal approach: Try to fix GPG issues without hardcoding distros
        echo "Attempting to fix GPG key issues..."
        # Method 1: Try updating with --allow-unauthenticated
        if apt-get update --allow-unauthenticated; then
            echo "Successfully updated package lists with --allow-unauthenticated"
        else
            echo "Failed with --allow-unauthenticated, trying to fix GPG keys..."
            
            # Method 2: Try to refresh GPG keys
            if command -v apt-key &>/dev/null; then
                echo "Refreshing GPG keys..."
                apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 648ACFD622F3D138 || true
                apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 0E98404D386FA1D9 || true
                apt-key adv --keyserver keyserver.ubuntu.com --recv-keys DCC9EFBF77E11517 || true
            fi
            
            # Method 3: Try updating with trusted repositories
            if ! apt-get update --allow-unauthenticated; then
                echo "Attempting to configure trusted repositories..."
                
                # Backup current sources
                cp /etc/apt/sources.list /etc/apt/sources.list.backup 2>/dev/null || true
                
                # Try to detect the distribution dynamically
                if [[ -f /etc/os-release ]]; then
                    source /etc/os-release
                    DISTRO_NAME="${VERSION_CODENAME:-${ID}}"
                    echo "Detected distribution: $DISTRO_NAME"
                elif [[ -f /etc/debian_version ]]; then
                    # Fallback for older Debian systems - only use known versions
                    DEBIAN_VERSION=$(cat /etc/debian_version | cut -d. -f1)
                    case $DEBIAN_VERSION in
                        12) DISTRO_NAME="bookworm" ;;
                        13) DISTRO_NAME="trixie" ;;
                        *)
                            echo "Error: Unknown Debian version $DEBIAN_VERSION. Cannot safely determine repository."
                            echo "Please ensure /etc/os-release is available or update this script for new Debian versions."
                            return 1
                            ;;
                    esac
                    echo "Detected Debian version: $DEBIAN_VERSION -> $DISTRO_NAME"
                else
                    echo "Error: Could not detect distribution"
                    echo "Neither /etc/os-release nor /etc/debian_version found."
                    return 1
                fi
                
                # Create a minimal trusted sources.list
                cat > /etc/apt/sources.list << EOF
deb [trusted=yes] http://deb.debian.org/debian $DISTRO_NAME main
deb [trusted=yes] http://deb.debian.org/debian $DISTRO_NAME-updates main
deb [trusted=yes] http://deb.debian.org/debian-security $DISTRO_NAME-security main
EOF
                
                # Try updating with the new configuration
                if ! apt-get update --allow-unauthenticated; then
                    echo "Error: Failed to update package lists even after reconfiguring repositories"
                    echo "Restoring original sources.list..."
                    cp /etc/apt/sources.list.backup /etc/apt/sources.list 2>/dev/null || true
                    return 1
                fi
            fi
        fi
    fi
    
    # Pre-configure timezone to avoid tzdata interactive prompts
    echo "tzdata tzdata/Areas select Etc" | debconf-set-selections
    echo "tzdata tzdata/Zones/Etc select UTC" | debconf-set-selections
    # Also set the timezone directly
    ln -sf /usr/share/zoneinfo/Etc/UTC /etc/localtime
    echo "Etc/UTC" > /etc/timezone
    
    # Check for missing dependencies first
    if [[ -f "/usr/bin/check-deps.sh" ]]; then
        echo "Checking build dependencies..."
        # Ensure the script has execute permissions
        chmod +x /usr/bin/check-deps.sh || true
        /usr/bin/check-deps.sh || {
            echo "Dependency check failed. Attempting to install anyway..."
        }
    fi
    
    # Preferred: install Build-Depends from local debian/control via mk-build-deps
    if [[ -f "debian/control" ]]; then
        echo "Attempting to install Build-Depends via mk-build-deps..."
        if mk-build-deps -t 'apt-get --no-install-recommends -y' -i -r debian/control; then
            echo "Successfully installed Build-Depends via mk-build-deps."
        else
            echo "mk-build-deps failed; attempting apt-get build-dep and manual fallback..."
            # Try apt-get build-dep on the local tree
            if apt-get build-dep -y .; then
                echo "Successfully installed build dependencies via apt-get build-dep."
            elif apt-get build-dep -y --allow-unauthenticated .; then
                echo "Successfully installed build dependencies with --allow-unauthenticated."
            else
                echo "Falling back to parsing Build-Depends from debian/control..."
                # Parse Build-Depends (first stanza) into package names (drop versions and alternatives)
                RAW_DEPS=$(awk '/^Build-Depends:/ {flag=1; sub(/^Build-Depends:[[:space:]]*/,""); print; next} /^[^ ]/ {flag=0} flag {print}' debian/control \
                    | tr -d '\n' | sed 's/, */\n/g' | sed 's/ (.*)//g' | sed 's/|/ /g' | awk '{print $1}' | grep -v -E '^[[:space:]]*$' || true)
                if [[ -n "${RAW_DEPS}" ]]; then
                    echo "Installing parsed Build-Depends: ${RAW_DEPS}"
                    if ! apt-get install -y --no-install-recommends ${RAW_DEPS}; then
                        echo "Warning: direct install of parsed Build-Depends failed; continuing."
                    fi
                fi
                # Heuristic: common C toolchain deps (useful for C/C++ projects like nginx)
                apt-get install -y --no-install-recommends build-essential || true
            fi
        fi
    else
        echo "No debian/control found; skipping mk-build-deps."
    fi

    # Build the package
    debuild -us -uc -b || {
        echo "Failed to build ${source_dir}."
        return 1
    }

    # Move built packages to output directory
    mkdir -p "${OUTPUT}"
    mv ../*.deb "${OUTPUT}/"
    # Include Ubuntu debug packages (.ddeb) if present
    mv ../*.ddeb "${OUTPUT}/" 2>/dev/null || true
    mv ../*.buildinfo "${OUTPUT}/"
    mv ../*.changes "${OUTPUT}/"
    
    # Rename packages to include distribution if DISTRO is set
    if [[ -n "${DISTRO}" ]]; then
        cd "${OUTPUT}"
        for deb in *.deb; do
            if [[ -f "$deb" ]]; then
                # Extract current version from the deb filename
                current_version=$(echo "$deb" | sed -n 's/.*_\([0-9]\+\.[0-9]\+\.[0-9]\+\)-[0-9]_.*/\1/p')
                if [[ -n "$current_version" ]]; then
                    newname=$(echo "$deb" | sed "s/_${current_version}-[0-9]_/_${current_version}-1.${DISTRO}_/")
                    if [[ "$deb" != "$newname" ]]; then
                        mv "$deb" "$newname"
                        echo "Renamed: $deb -> $newname"
                    fi
                fi
            fi
        done
    fi
    
    echo "Package built successfully for ${source_dir}."
}

# Find all packages and build them
echo "SOURCES directory: ${SOURCES}"
echo "Contents of SOURCES:"
ls -la "${SOURCES}" || echo "Cannot list SOURCES directory"

package_dirs=$(find_packages)

echo "Found package directories:"
echo "$package_dirs"

total_modules=$(echo "$package_dirs" | wc -l)
if [[ "$total_modules" -eq 0 ]]; then
  echo "No debian directories found. Exiting."
  exit 1
fi

success_count=0
fail_count=0
failure_tolerance=0.1  # Example: Allow up to 10% of modules to fail

for package_dir in $package_dirs; do
  if build_package "$package_dir"; then
    success_count=$((success_count + 1))
  else
    fail_count=$((fail_count + 1))
  fi

  # Check if failure tolerance is exceeded
  if [[ $(echo "scale=2; $fail_count / $total_modules" | bc) > $failure_tolerance ]]; then
    echo "Built $success_count packages successfully, but $fail_count failed out of $total_modules total packages."
    echo "Failure tolerance exceeded. Exiting build."
    exit 1
  fi
done

# Fix user IDs for output files
if [ -n "${OUTPUT_UID}" ]; then
   chown -R "${OUTPUT_UID}:${OUTPUT_UID}" "${OUTPUT}"/*
fi
