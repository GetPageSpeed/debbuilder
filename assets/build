#!/usr/bin/env bash

# use exit codes of failing commands
set -exo pipefail

# Set non-interactive frontend to avoid prompts during package installation
export DEBIAN_FRONTEND=noninteractive

SOURCES=${SOURCES-/sources}
OUTPUT=${OUTPUT-${SOURCES}}

# Initialize default values for options and flags
FORCE=false
ENABLE_REPOS=""
EXTERNAL_BUILD_SCRIPT=""
NO_FETCH=false

# Store original arguments for checking --no-fetch
ORIGINAL_ARGS="$*"

# Loop through the arguments
while [[ "$1" != "" ]]; do
    case $1 in
        --force )
            FORCE=true
            ;;
        --enable-repos )
            shift # Move to the next argument, which should be the value for --option
            if [[ -n $1 ]]; then
                ENABLE_REPOS=$1
            else
                echo "Error: --enable-repos requires a value."
                exit 1
            fi
            ;;
        --external-build-script )
            shift # Move to the next argument, which should be the URL
            if [[ -n $1 ]]; then
                EXTERNAL_BUILD_SCRIPT=$1
            else
                echo "Error: --external-build-script requires a URL."
                exit 1
            fi
            ;;
        --no-fetch )
            NO_FETCH=true
            ;;
        * )
            echo "Invalid option: $1"
            exit 1
            ;;
    esac
    shift # Move to the next argument
done

# If external build script is specified, fetch and use it
if [[ -n "${EXTERNAL_BUILD_SCRIPT}" ]]; then
    echo "Fetching external build script from: ${EXTERNAL_BUILD_SCRIPT}"
    if curl -fsSL "${EXTERNAL_BUILD_SCRIPT}" > /tmp/external-build.sh; then
        chmod +x /tmp/external-build.sh
        exec /tmp/external-build.sh "$@"
    else
        echo "Failed to fetch external build script. Falling back to built-in script."
    fi
fi

# Try to fetch and execute the latest build script from GitHub
# This allows getting the latest build logic without rebuilding Docker images
# We add --no-fetch to prevent infinite recursion
if [[ "$NO_FETCH" != "true" ]]; then
    echo "Attempting to fetch latest build script from GitHub..."
    # Add cache busting to prevent GitHub from serving cached versions
    cache_buster=$(date +%s)
    if curl -fsSL "https://raw.githubusercontent.com/GetPageSpeed/debbuilder/refs/heads/main/assets/build?${cache_buster}" > /tmp/latest-build.sh; then
        chmod +x /tmp/latest-build.sh
        echo "Successfully fetched latest build script. Executing..."
        exec /tmp/latest-build.sh --no-fetch "$@"
    else
        echo "Failed to fetch latest build script. Using local version."
    fi
fi

# Enable additional repositories if needed
if [[ -n ${ENABLE_REPOS} ]]; then
  add-apt-repository "${ENABLE_REPOS}" || exit 1
  apt-get update
fi

# Look for all subdirectories containing a `debian` directory
find_packages() {
    find "${SOURCES}" -mindepth 1 -type d -name debian -exec dirname {} \;
}

# Function to check if the package can be skipped
check_packages_in_repo() {
    local source_dir=$1
    cd "$source_dir"
    if [[ -f "debian/control" ]]; then
        # Parse the package name and version
        package_name=$(dpkg-parsechangelog --show-field Source)
        package_version=$(dpkg-parsechangelog --show-field Version)

        # Check if package already exists in repository
        if apt-cache show "${package_name}=${package_version}" &>/dev/null; then
            echo "Package ${package_name} version ${package_version} already exists. Skipping build."
            return 0
        else
            echo "Package ${package_name} version ${package_version} is missing. Building it."
            return 1
        fi
    else
        echo "No debian/control file found in ${source_dir}. Skipping build."
        return 0
    fi
}

# Build the debian package
build_package() {
    local source_dir=$1
    echo "Building package from directory: ${source_dir}"
    echo "Current directory before cd: $(pwd)"
    cd "$source_dir"
    echo "Current directory after cd: $(pwd)"

    if [ "$FORCE" = true ]; then
        echo "Building package without checking repository because --force is set"
    elif check_packages_in_repo "${source_dir}"; then
        echo "Skipping build for ${source_dir}."
        return 0
    fi

    # Use upstream.yml (required) for fetching sources
    if [[ -f "upstream.yml" ]]; then
        echo "Found upstream.yml; using it for upstream source resolution..."
        # Determine package name early
            PACKAGE=""
            if [[ -f "debian/control" ]]; then
            PACKAGE=$(awk '/^Source:/{print $2; exit}' debian/control || true)
            fi
            if [[ -z "${PACKAGE}" ]]; then
                PACKAGE=$(basename "$(pwd)")
            fi
        # Parse version and source template (support quoted or unquoted values)
        UPSTREAM_VERSION="$(awk -F\" '/^version:[[:space:]]*\"/{print $2; exit} /^version:[[:space:]]*[0-9]/{gsub(/^version:[[:space:]]*/,""); print; exit}' upstream.yml || true)"
        TEMPLATE="$(awk -F\" '/^source:[[:space:]]*\"/{print $2; exit} /^source:[[:space:]]*[^#]/{sub(/^source:[[:space:]]*/,""); gsub(/[[:space:]]+#.*/,""); print; exit}' upstream.yml || true)"
        if [[ -z "${UPSTREAM_VERSION}" ]] || [[ -z "${TEMPLATE}" ]]; then
            echo "Error: upstream.yml must define both version and source"
                        return 1
        fi
        # Build final URL (support {version} and optional {name})
        URL="${TEMPLATE//\{version\}/${UPSTREAM_VERSION}}"
        if printf '%s' "${URL}" | grep -q '{name}'; then
            URL="${URL//\{name\}/${PACKAGE}}"
        fi
        echo "Resolved source URL: ${URL}"
        # Skip download if already prepared
        if [[ -d "${PACKAGE}-${UPSTREAM_VERSION}" ]]; then
            echo "Source directory ${PACKAGE}-${VERSION} already present; skipping download."
            cd "${PACKAGE}-${UPSTREAM_VERSION}"
        else
            FILENAME="$(basename "${URL}")"
            echo "Downloading ${FILENAME}..."
            if curl -fsSL -o "${FILENAME}" "${URL}"; then
                echo "Extracting ${FILENAME}..."
                tar -xf "${FILENAME}"
                # Detect top-level directory name from tar
                TOPDIR="$(tar -tf "${FILENAME}" | head -1 | cut -d/ -f1)"
                if [[ -n "${TOPDIR}" ]] && [[ -d "${TOPDIR}" ]]; then
                    # Normalize nested layout like nginx-X/nginx-X/*
                    if [[ -d "${TOPDIR}/${TOPDIR}" ]]; then
                        mv "${TOPDIR}/${TOPDIR}"/* "${TOPDIR}/"
                        rmdir "${TOPDIR}/${TOPDIR}" || true
                    fi
                    # If packaging is outside, copy it in
                    if [[ -d "debian" ]] && [[ ! -d "${TOPDIR}/debian" ]]; then
                        cp -r debian "${TOPDIR}/"
                    fi
                    # Enter extracted top-level directory for build
                    cd "${TOPDIR}"
                fi
                # Remove downloaded archive to keep workspace clean
                rm -f "${FILENAME}" || true
            else
                echo "Error: failed to download ${URL}"
                return 1
            fi
        fi
    else
        echo "Error: upstream.yml not found. This builder requires upstream.yml with 'version' and 'source'."
        return 1
    fi

    # After fetching sources, ensure we are inside the actual source directory containing debian/
    # If we are still at the original root (no debian/ here), try to locate and enter it
    if [[ -d "debian" ]]; then
        echo "Found debian directory in current location"
        DEBIAN_DIR="."
    else
        # Look for debian directory in subdirectories
        DEBIAN_DIR=$(find . -name "debian" -type d | head -1 | xargs dirname)
        if [[ -n "${DEBIAN_DIR}" ]]; then
            echo "Found debian directory in: ${DEBIAN_DIR}"
            cd "${DEBIAN_DIR}"
        else
            # If no debian directory found, check if we're in a subdirectory that was created by setup.sh
            # Look for setup.py or other build files to determine if this is the source directory
            if [[ -f "setup.py" ]] || [[ -f "pyproject.toml" ]] || [[ -f "Makefile" ]]; then
                echo "Found source directory with build files in current location"
                DEBIAN_DIR="."
            else
                echo "Error: No debian directory or source files found after setup.sh"
                echo "Current directory contents:"
                ls -la
                echo "Looking for debian directories:"
                find . -name "debian" -type d 2>/dev/null || echo "No debian directories found"
                return 1
            fi
        fi
    fi

    # Check if we need to find the source code in a subdirectory
    # This handles cases where the debian directory is in the parent but source is in a subdirectory
    if [[ ! -f "setup.py" ]] && [[ ! -f "pyproject.toml" ]] && [[ ! -f "Makefile" ]]; then
        echo "No build files found in current directory, looking for source in subdirectories..."
        SOURCE_DIR=$(find . -name "setup.py" -o -name "pyproject.toml" -o -name "Makefile" | head -1 | xargs dirname)
        if [[ -n "${SOURCE_DIR}" ]]; then
            echo "Found source directory: ${SOURCE_DIR}"
            cd "${SOURCE_DIR}"
            echo "Changed to source directory: $(pwd)"
        else
            echo "No source files found in subdirectories"
            echo "Available files:"
            find . -type f -name "setup.py" -o -name "pyproject.toml" -o -name "Makefile" 2>/dev/null || echo "No build files found"
        fi
    fi

    # Check for upstream version if not set (read only from upstream.yml)
    if [[ -z "${UPSTREAM_VERSION}" ]] && [[ -f "upstream.yml" ]]; then
        UPSTREAM_VERSION="$(awk -F\" '/^version:[[:space:]]*\"/{print $2; exit} /^version:[[:space:]]*[0-9]/{gsub(/^version:[[:space:]]*/,""); print; exit}' upstream.yml || true)"
    fi

    if [[ -z "${UPSTREAM_VERSION}" ]]; then
        echo "Warning: No upstream version found; using existing changelog version."
    fi

    # Determine suite codename and compute Debian REVISION from /etc/os-release only
    if [[ -f /etc/os-release ]]; then
        # shellcheck disable=SC1091
        . /etc/os-release
        SUITE_CODENAME="${VERSION_CODENAME:-}"
        OS_ID="${ID:-}"
        OS_VERSION_ID="${VERSION_ID:-}"
        if [[ -z "${SUITE_CODENAME}" || -z "${OS_ID}" || -z "${OS_VERSION_ID}" ]]; then
            echo "Error: Missing fields in /etc/os-release (need VERSION_CODENAME, ID, VERSION_ID)."
            return 1
        fi
    else
        echo "Error: /etc/os-release not found; cannot determine suite and distro token."
        return 1
    fi

    # Compute distro token
    # - Debian: deb${VERSION_ID} (e.g., deb12)
    # - Ubuntu: ubuntu${VERSION_ID//./} (e.g., ubuntu2204)
    DISTRO_TOKEN=""
    if [[ "${OS_ID}" == "debian" ]]; then
        DISTRO_TOKEN="deb${OS_VERSION_ID}"
    elif [[ "${OS_ID}" == "ubuntu" ]]; then
        DISTRO_TOKEN="ubuntu${OS_VERSION_ID//./}"
    else
        echo "Error: Unsupported OS_ID '${OS_ID}'. Only debian/ubuntu are supported."
        return 1
    fi

    # Determine flavor based on branch env (GIT_BRANCH preferred)
    RAW_BRANCH="${GIT_BRANCH:-${CIRCLE_BRANCH:-${BRANCH:-}}}"
    if [[ "${RAW_BRANCH}" == "main" ]]; then
        FLAVOR="stable"
    elif [[ "${RAW_BRANCH}" == "master" ]]; then
        FLAVOR="stable"
    else
        FLAVOR="${RAW_BRANCH}"
    fi

    # Compose Debian revision suffix (no release here; template controls -<release>~)
    # Example: gps1+deb12+mainline
    REVISION="gps1+${DISTRO_TOKEN}+${FLAVOR}"

    # Stamp debian/changelog:
    # - If changelog missing: create minimal templated changelog with placeholders, then stamp
    # - If placeholders present: replace VERSION, REVISION, SUITE_CODENAME
    # - Else: fallback to appending ~${SUITE_CODENAME} and set Distribution
    if [[ ! -f "debian/changelog" ]]; then
        echo "debian/changelog not found; generating minimal templated changelog."
        PACKAGE_NAME="$(dpkg-parsechangelog --show-field Source 2>/dev/null || true)"
        if [[ -z "${PACKAGE_NAME}" && -f "debian/control" ]]; then
            PACKAGE_NAME="$(awk '/^Source:/{print $2; exit}' debian/control || true)"
        fi
        if [[ -z "${PACKAGE_NAME}" ]]; then
            PACKAGE_NAME="$(basename "$(pwd)")"
        fi
        {
            echo "${PACKAGE_NAME} (VERSION-1~REVISION) SUITE_CODENAME; urgency=medium"
            echo
            echo "  * Automated build."
            echo
            echo " -- GetPageSpeed LLC <builder@getpagespeed.com>  $(date -R)"
        } > debian/changelog
    fi

    STAMPED=false
    if grep -qE 'VERSION|REVISION|SUITE_CODENAME' debian/changelog; then
        [[ -n "${UPSTREAM_VERSION}" ]] && sed -i "s/VERSION/${UPSTREAM_VERSION}/g" debian/changelog
        sed -i "s/REVISION/${REVISION}/g" debian/changelog
        sed -i "s/SUITE_CODENAME/${SUITE_CODENAME}/g" debian/changelog
        echo "Stamped debian/changelog with VERSION=${UPSTREAM_VERSION}, REVISION=${REVISION}, SUITE_CODENAME=${SUITE_CODENAME}"
        STAMPED=true
    fi

    # If debian/control uses VERSION as a placeholder anywhere
    # (e.g. Provides: nginx-rVERSION, Depends: foo-VERSION, etc.),
    # stamp it to the resolved upstream version so this logic is
    # reusable beyond nginx-specific packages.
    if [[ -n "${UPSTREAM_VERSION}" ]] && [[ -f "debian/control" ]] && grep -q "VERSION" debian/control; then
        sed -i "s/VERSION/${UPSTREAM_VERSION}/g" debian/control
        echo "Stamped debian/control with VERSION=${UPSTREAM_VERSION}"
    fi

    if [[ "${STAMPED}" != true ]]; then
        # Fallback path: per-suite suffixing and distribution set, without altering base version semantics
        current_version="$(dpkg-parsechangelog --show-field Version || true)"
        if [[ -n "${current_version}" ]]; then
            if [[ "${current_version}" == *"~${SUITE_CODENAME}"* ]]; then
                echo "Changelog already contains per-suite suffix ~${SUITE_CODENAME}"
                if command -v dch >/dev/null 2>&1; then
                    dch -D "${SUITE_CODENAME}" --force-distribution --no-auto-nmu -m "CI: set distribution to ${SUITE_CODENAME}" || true
                else
                    sed -i -E "1s/^(\S+ \()[^)]*(\) )(\S+)(; urgency=)/\1${current_version}\2${SUITE_CODENAME}\4/" debian/changelog || true
                fi
            else
                new_version="${current_version}~${SUITE_CODENAME}"
                echo "Updating changelog version: ${current_version} -> ${new_version} (distribution ${SUITE_CODENAME})"
                if command -v dch >/dev/null 2>&1; then
                    dch -v "${new_version}" --force-bad-version -D "${SUITE_CODENAME}" --force-distribution --no-auto-nmu -m "CI: per-suite suffix ~${SUITE_CODENAME}"
                else
                    sed -i -E "1s/^(\S+ \()([^)]*)(\) )/\1${new_version}\3/" debian/changelog
                    sed -i -E "1s/^(\S+ \([^)]*\) )(\S+)(; urgency=)/\1${SUITE_CODENAME}\3/" debian/changelog
                fi
            fi
        else
            echo "Warning: could not parse current changelog version; leaving changelog unmodified."
        fi
    fi

    # Clean up old build artifacts
    if [[ -f "debian/rules" ]]; then
        make -f debian/rules clean || dh clean || true
    fi
    
    # Ubuntu focal: downgrade debhelper compat level to 12 before resolving deps
    if [[ "${OS_ID}" == "ubuntu" && "${SUITE_CODENAME}" == "focal" ]]; then
        if [[ -f "debian/control" ]]; then
            if grep -qE 'debhelper-compat[[:space:]]*\(= *13\)' debian/control; then
                echo "Focal detected: rewriting debhelper-compat (= 13) -> (= 12) in debian/control"
                sed -i -E 's/debhelper-compat[[:space:]]*\(= *13\)/debhelper-compat (= 12)/g' debian/control
            fi
            if grep -qE 'debhelper[[:space:]]*\(>= *13' debian/control; then
                echo "Focal detected: rewriting debhelper (>= 13) -> (>= 12) in debian/control"
                sed -i -E 's/debhelper[[:space:]]*\(>= *13/debhelper (>= 12/g' debian/control
            fi
        fi
        if [[ -f "debian/compat" ]]; then
            if grep -q '^13$' debian/compat; then
                echo "Focal detected: rewriting debian/compat 13 -> 12"
                echo "12" > debian/compat
            fi
        fi
    fi
 
    # Install build dependencies from the current directory (which should have debian/control)
    echo "Installing build dependencies from $(pwd)..."

    # Ensure package lists are up to date
    echo "Updating package lists..."
    if ! apt-get update; then
        echo "Warning: Failed to update package lists, attempting to fix repository configuration..."
        # Universal approach: Try to fix GPG issues without hardcoding distros
        echo "Attempting to fix GPG key issues..."
        # Method 1: Try updating with --allow-unauthenticated
        if apt-get update --allow-unauthenticated; then
            echo "Successfully updated package lists with --allow-unauthenticated"
        else
            echo "Failed with --allow-unauthenticated, trying to fix GPG keys..."

            # Method 2: Try to refresh GPG keys
            if command -v apt-key &>/dev/null; then
                echo "Refreshing GPG keys..."
                apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 648ACFD622F3D138 || true
                apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 0E98404D386FA1D9 || true
                apt-key adv --keyserver keyserver.ubuntu.com --recv-keys DCC9EFBF77E11517 || true
            fi

            # Method 3: Try updating with trusted repositories
            if ! apt-get update --allow-unauthenticated; then
                echo "Attempting to configure trusted repositories..."

                # Backup current sources
                cp /etc/apt/sources.list /etc/apt/sources.list.backup 2>/dev/null || true

                # Try to detect the distribution dynamically
                if [[ -f /etc/os-release ]]; then
                    source /etc/os-release
                    DISTRO_NAME="${VERSION_CODENAME:-${ID}}"
                    echo "Detected distribution: $DISTRO_NAME"
                elif [[ -f /etc/debian_version ]]; then
                    # Fallback for older Debian systems - only use known versions
                    DEBIAN_VERSION=$(cat /etc/debian_version | cut -d. -f1)
                    case $DEBIAN_VERSION in
                        12) DISTRO_NAME="bookworm" ;;
                        13) DISTRO_NAME="trixie" ;;
                        *)
                            echo "Error: Unknown Debian version $DEBIAN_VERSION. Cannot safely determine repository."
                            echo "Please ensure /etc/os-release is available or update this script for new Debian versions."
                            return 1
                            ;;
                    esac
                    echo "Detected Debian version: $DEBIAN_VERSION -> $DISTRO_NAME"
                else
                    echo "Error: Could not detect distribution"
                    echo "Neither /etc/os-release nor /etc/debian_version found."
                    return 1
                fi

                # Create a minimal trusted sources.list
                cat > /etc/apt/sources.list << EOF
deb [trusted=yes] http://deb.debian.org/debian $DISTRO_NAME main
deb [trusted=yes] http://deb.debian.org/debian $DISTRO_NAME-updates main
deb [trusted=yes] http://deb.debian.org/debian-security $DISTRO_NAME-security main
EOF

                # Try updating with the new configuration
                if ! apt-get update --allow-unauthenticated; then
                    echo "Error: Failed to update package lists even after reconfiguring repositories"
                    echo "Restoring original sources.list..."
                    cp /etc/apt/sources.list.backup /etc/apt/sources.list 2>/dev/null || true
                    return 1
                fi
            fi
        fi
    fi

    # Pre-configure timezone to avoid tzdata interactive prompts
    echo "tzdata tzdata/Areas select Etc" | debconf-set-selections
    echo "tzdata tzdata/Zones/Etc select UTC" | debconf-set-selections
    # Also set the timezone directly
    ln -sf /usr/share/zoneinfo/Etc/UTC /etc/localtime
    echo "Etc/UTC" > /etc/timezone

    # Check for missing dependencies first
    if [[ -f "/usr/bin/check-deps.sh" ]]; then
        echo "Checking build dependencies..."
        # Ensure the script has execute permissions
        chmod +x /usr/bin/check-deps.sh || true
        /usr/bin/check-deps.sh || {
            echo "Dependency check failed. Attempting to install anyway..."
        }
    fi

    # Preferred: install Build-Depends from local debian/control via mk-build-deps
    if [[ -f "debian/control" ]]; then
        echo "Attempting to install Build-Depends via mk-build-deps..."
        if mk-build-deps -t 'apt-get --no-install-recommends -y' -i -r debian/control; then
            echo "Successfully installed Build-Depends via mk-build-deps."
        else
            echo "mk-build-deps failed; attempting apt-get build-dep and manual fallback..."
            # Try apt-get build-dep on the local tree
            if apt-get build-dep -y .; then
                echo "Successfully installed build dependencies via apt-get build-dep."
            elif apt-get build-dep -y --allow-unauthenticated .; then
                echo "Successfully installed build dependencies with --allow-unauthenticated."
            else
                echo "Falling back to parsing Build-Depends from debian/control..."
                # Parse Build-Depends (first stanza) into package names (drop versions and alternatives)
                RAW_DEPS=$(awk '/^Build-Depends:/ {flag=1; sub(/^Build-Depends:[[:space:]]*/,""); print; next} /^[^ ]/ {flag=0} flag {print}' debian/control \
                    | tr -d '\n' | sed 's/, */\n/g' | sed 's/ (.*)//g' | sed 's/|/ /g' | awk '{print $1}' | grep -v -E '^[[:space:]]*$' || true)
                if [[ -n "${RAW_DEPS}" ]]; then
                    echo "Installing parsed Build-Depends: ${RAW_DEPS}"
                    if ! apt-get install -y --no-install-recommends ${RAW_DEPS}; then
                        echo "Warning: direct install of parsed Build-Depends failed; continuing."
                    fi
                fi
                # Heuristic: common C toolchain deps (useful for C/C++ projects like nginx)
                apt-get install -y --no-install-recommends build-essential || true
            fi
        fi
    else
        echo "No debian/control found; skipping mk-build-deps."
    fi

    # Build the package
    debuild -us -uc -b || {
        echo "Failed to build ${source_dir}."
        return 1
    }

    # Move built packages to output directory
    mkdir -p "${OUTPUT}"
    mv ../*.deb "${OUTPUT}/"
    # Include Ubuntu debug packages (.ddeb) if present
    mv ../*.ddeb "${OUTPUT}/" 2>/dev/null || true
    mv ../*.buildinfo "${OUTPUT}/"
    mv ../*.changes "${OUTPUT}/"

    # Rename packages to include distribution if DISTRO is set
    if [[ -n "${DISTRO}" ]]; then
        cd "${OUTPUT}"
        for deb in *.deb; do
            if [[ -f "$deb" ]]; then
                # Extract current version from the deb filename
                current_version=$(echo "$deb" | sed -n 's/.*_\([0-9]\+\.[0-9]\+\.[0-9]\+\)-[0-9]_.*/\1/p')
                if [[ -n "$current_version" ]]; then
                    newname=$(echo "$deb" | sed "s/_${current_version}-[0-9]_/_${current_version}-1.${DISTRO}_/")
                    if [[ "$deb" != "$newname" ]]; then
                        mv "$deb" "$newname"
                        echo "Renamed: $deb -> $newname"
                    fi
                fi
            fi
        done
    fi

    echo "Package built successfully for ${source_dir}."
}

# Find all packages and build them
echo "SOURCES directory: ${SOURCES}"
echo "Contents of SOURCES:"
ls -la "${SOURCES}" || echo "Cannot list SOURCES directory"

package_dirs=$(find_packages)

echo "Found package directories:"
echo "$package_dirs"

total_modules=$(echo "$package_dirs" | wc -l)
if [[ "$total_modules" -eq 0 ]]; then
  echo "No debian directories found. Exiting."
  exit 1
fi

success_count=0
fail_count=0
failure_tolerance=0.1  # Example: Allow up to 10% of modules to fail

for package_dir in $package_dirs; do
  if build_package "$package_dir"; then
    success_count=$((success_count + 1))
  else
    fail_count=$((fail_count + 1))
  fi

  # Check if failure tolerance is exceeded
  if [[ $(echo "scale=2; $fail_count / $total_modules" | bc) > $failure_tolerance ]]; then
    echo "Built $success_count packages successfully, but $fail_count failed out of $total_modules total packages."
    echo "Failure tolerance exceeded. Exiting build."
    exit 1
  fi
done

# Fix user IDs for output files
if [ -n "${OUTPUT_UID}" ]; then
   chown -R "${OUTPUT_UID}:${OUTPUT_UID}" "${OUTPUT}"/*
fi
