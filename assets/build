#!/usr/bin/env bash

# use exit codes of failing commands
set -exo pipefail

# Set non-interactive frontend to avoid prompts during package installation
export DEBIAN_FRONTEND=noninteractive

SOURCES=${SOURCES-/sources}
OUTPUT=${OUTPUT-${SOURCES}}

# Initialize default values for options and flags
FORCE=false
ENABLE_REPOS=""

# Loop through the arguments
while [[ "$1" != "" ]]; do
    case $1 in
        --force )
            FORCE=true
            ;;
        --enable-repos )
            shift # Move to the next argument, which should be the value for --option
            if [[ -n $1 ]]; then
                ENABLE_REPOS=$1
            else
                echo "Error: --enable-repos requires a value."
                exit 1
            fi
            ;;
        * )
            echo "Invalid option: $1"
            exit 1
            ;;
    esac
    shift # Move to the next argument
done

# Enable additional repositories if needed
if [[ -n ${ENABLE_REPOS} ]]; then
  add-apt-repository "${ENABLE_REPOS}" || exit 1
  apt-get update
fi

# Look for all subdirectories containing a `debian` directory
find_packages() {
    find "${SOURCES}" -mindepth 1 -type d -name debian -exec dirname {} \;
}

# Function to check if the package can be skipped
check_packages_in_repo() {
    local source_dir=$1
    cd "$source_dir"
    if [[ -f "debian/control" ]]; then
        # Parse the package name and version
        package_name=$(dpkg-parsechangelog --show-field Source)
        package_version=$(dpkg-parsechangelog --show-field Version)

        # Check if package already exists in repository
        if apt-cache show "${package_name}=${package_version}" &>/dev/null; then
            echo "Package ${package_name} version ${package_version} already exists. Skipping build."
            return 0
        else
            echo "Package ${package_name} version ${package_version} is missing. Building it."
            return 1
        fi
    else
        echo "No debian/control file found in ${source_dir}. Skipping build."
        return 0
    fi
}

# Build the debian package
build_package() {
    local source_dir=$1
    cd "$source_dir"

    if [ "$FORCE" = true ]; then
        echo "Building package without checking repository because --force is set"
    elif check_packages_in_repo "${source_dir}"; then
        echo "Skipping build for ${source_dir}."
        return 0
    fi

    # Check if this package requires special setup
    if [[ -f "setup.sh" ]]; then
        echo "Running setup script for ${source_dir}..."
        chmod +x setup.sh
        ./setup.sh || {
            echo "Failed to run setup script for ${source_dir}."
            return 1
        }
        
        # After setup.sh, we might be in a different directory
        # Find the debian directory to determine where to install dependencies
        if [[ -d "debian" ]]; then
            echo "Found debian directory in current location"
            DEBIAN_DIR="."
        else
            # Look for debian directory in subdirectories
            DEBIAN_DIR=$(find . -name "debian" -type d | head -1 | xargs dirname)
            if [[ -n "${DEBIAN_DIR}" ]]; then
                echo "Found debian directory in: ${DEBIAN_DIR}"
                cd "${DEBIAN_DIR}"
            else
                echo "Error: No debian directory found after setup.sh"
                return 1
            fi
        fi
    fi

    # Check if we need to read from debmacros and update changelog
    if [[ -f "debmacros" ]]; then
        echo "Reading version from debmacros..."
        
        # Try to find version in debmacros - look for common patterns
        VERSION=""
        if grep -q "%lastversion_version" debmacros; then
            VERSION=$(grep "%lastversion_version" debmacros | awk '{print $2}')
        elif grep -q "%version" debmacros; then
            VERSION=$(grep "%version" debmacros | awk '{print $2}')
        elif grep -q "VERSION" debmacros; then
            VERSION=$(grep "VERSION" debmacros | awk '{print $2}')
        fi
        
        if [[ -n "${VERSION}" ]]; then
            echo "Updating version references with version ${VERSION} and distribution ${DISTRO}..."
            
            # Update changelog if it exists
            if [[ -f "debian/changelog" ]]; then
                sed -i "s/VERSION/${VERSION}/g" debian/changelog
                sed -i "s/DISTRO/${DISTRO}/g" debian/changelog
                echo "Updated debian/changelog"
            fi
            
            # Update any other files that might contain version references
            # Look for common patterns in debian directory
            for file in debian/*; do
                if [[ -f "$file" ]]; then
                    # Update any remaining VERSION placeholders
                    if grep -q "VERSION" "$file"; then
                        sed -i "s/VERSION/${VERSION}/g" "$file"
                        echo "Updated version references in $file"
                    fi
                    # Update any remaining DISTRO placeholders
                    if grep -q "DISTRO" "$file"; then
                        sed -i "s/DISTRO/${DISTRO}/g" "$file"
                        echo "Updated distribution references in $file"
                    fi
                fi
            done
            
            # Also check for version references in the main directory
            for file in *.py *.txt *.md *.rst; do
                if [[ -f "$file" ]]; then
                    # Update any remaining VERSION placeholders
                    if grep -q "VERSION" "$file"; then
                        sed -i "s/VERSION/${VERSION}/g" "$file"
                        echo "Updated version references in $file"
                    fi
                fi
            done
        else
            echo "Warning: No version found in debmacros file"
        fi
    fi

    # Clean up old build artifacts
    debuild clean || true

    # Install build dependencies from the current directory (which should have debian/control)
    echo "Installing build dependencies from $(pwd)..."
    
    # Pre-configure timezone to avoid tzdata interactive prompts
    echo "tzdata tzdata/Areas select Etc" | debconf-set-selections
    echo "tzdata tzdata/Zones/Etc select UTC" | debconf-set-selections
    # Also set the timezone directly
    ln -sf /usr/share/zoneinfo/Etc/UTC /etc/localtime
    echo "Etc/UTC" > /etc/timezone
    
    mk-build-deps -t "apt-get --no-install-recommends -y" -ir || {
        echo "Failed to install build dependencies. Trying alternative approach..."
        # Try installing dependencies manually if mk-build-deps fails
        apt-get update
        # Use additional flags to ensure non-interactive installation
        apt-get install -y --no-install-recommends -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" dh-python python3-all python3-setuptools python3-pytest python3-packaging python3-cachecontrol python3-appdirs python3-feedparser python3-yaml python3-tqdm python3-bs4 python3-html5lib python3-dateutil python3-distro pandoc || {
            echo "Failed to install build dependencies manually"
            return 1
        }
    }

    # Build the package
    debuild -us -uc -b || {
        echo "Failed to build ${source_dir}."
        return 1
    }

    # Move built packages to output directory
    mkdir -p "${OUTPUT}"
    mv ../*.deb "${OUTPUT}/"
    mv ../*.buildinfo "${OUTPUT}/"
    mv ../*.changes "${OUTPUT}/"
    
    # Rename packages to include distribution if DISTRO is set
    if [[ -n "${DISTRO}" ]]; then
        cd "${OUTPUT}"
        for deb in *.deb; do
            if [[ -f "$deb" ]]; then
                # Extract current version from the deb filename
                current_version=$(echo "$deb" | sed -n 's/.*_\([0-9]\+\.[0-9]\+\.[0-9]\+\)-[0-9]_.*/\1/p')
                if [[ -n "$current_version" ]]; then
                    newname=$(echo "$deb" | sed "s/_${current_version}-[0-9]_/_${current_version}-1.${DISTRO}_/")
                    if [[ "$deb" != "$newname" ]]; then
                        mv "$deb" "$newname"
                        echo "Renamed: $deb -> $newname"
                    fi
                fi
            fi
        done
    fi
    
    echo "Package built successfully for ${source_dir}."
}

# Find all packages and build them
package_dirs=$(find_packages)

total_modules=$(echo "$package_dirs" | wc -l)
if [[ "$total_modules" -eq 0 ]]; then
  echo "No debian directories found. Exiting."
  exit 1
fi

success_count=0
fail_count=0
failure_tolerance=0.1  # Example: Allow up to 10% of modules to fail

for package_dir in $package_dirs; do
  if build_package "$package_dir"; then
    success_count=$((success_count + 1))
  else
    fail_count=$((fail_count + 1))
  fi

  # Check if failure tolerance is exceeded
  if [[ $(echo "scale=2; $fail_count / $total_modules" | bc) > $failure_tolerance ]]; then
    echo "Built $success_count packages successfully, but $fail_count failed out of $total_modules total packages."
    echo "Failure tolerance exceeded. Exiting build."
    exit 1
  fi
done

# Fix user IDs for output files
if [ -n "${OUTPUT_UID}" ]; then
   chown -R "${OUTPUT_UID}:${OUTPUT_UID}" "${OUTPUT}"/*
fi
