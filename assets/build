#!/usr/bin/env bash

# use exit codes of failing commands
set -exo pipefail

SOURCES=${SOURCES-/sources}
OUTPUT=${OUTPUT-${SOURCES}}

# Initialize default values for options and flags
FORCE=false
ENABLE_REPOS=""

# Loop through the arguments
while [[ "$1" != "" ]]; do
    case $1 in
        --force )
            FORCE=true
            ;;
        --enable-repos )
            shift # Move to the next argument, which should be the value for --option
            if [[ -n $1 ]]; then
                ENABLE_REPOS=$1
            else
                echo "Error: --enable-repos requires a value."
                exit 1
            fi
            ;;
        * )
            echo "Invalid option: $1"
            exit 1
            ;;
    esac
    shift # Move to the next argument
done

# Enable additional repositories if needed
if [[ -n ${ENABLE_REPOS} ]]; then
  add-apt-repository "${ENABLE_REPOS}" || exit 1
  apt-get update
fi

# Look for all subdirectories containing a `debian` directory
find_packages() {
    find "${SOURCES}" -mindepth 1 -type d -name debian -exec dirname {} \;
}

# Function to check if the package can be skipped
check_packages_in_repo() {
    local source_dir=$1
    cd "$source_dir"
    if [[ -f "debian/control" ]]; then
        # Parse the package name and version
        package_name=$(dpkg-parsechangelog --show-field Source)
        package_version=$(dpkg-parsechangelog --show-field Version)

        # Check if package already exists in repository
        if apt-cache show "${package_name}=${package_version}" &>/dev/null; then
            echo "Package ${package_name} version ${package_version} already exists. Skipping build."
            return 0
        else
            echo "Package ${package_name} version ${package_version} is missing. Building it."
            return 1
        fi
    else
        echo "No debian/control file found in ${source_dir}. Skipping build."
        return 0
    fi
}

# Build the debian package
build_package() {
    local source_dir=$1
    cd "$source_dir"

    if [ "$FORCE" = true ]; then
        echo "Building package without checking repository because --force is set"
    elif check_packages_in_repo "${source_dir}"; then
        echo "Skipping build for ${source_dir}."
        return 0
    fi

    # Clean up old build artifacts
    debuild clean || true

    # Install build dependencies
    mk-build-deps -t "apt-get --no-install-recommends -y" -ir || true

    # Build the package
    debuild -us -uc -b || {
        echo "Failed to build ${source_dir}."
        return 1
    }

    # Move built packages to output directory
    mkdir -p "${OUTPUT}"
    mv ../*.deb "${OUTPUT}/"
    mv ../*.buildinfo "${OUTPUT}/"
    mv ../*.changes "${OUTPUT}/"
    echo "Package built successfully for ${source_dir}."
}

# Find all packages and build them
package_dirs=$(find_packages)

total_modules=$(echo "$package_dirs" | wc -l)
if [[ "$total_modules" -eq 0 ]]; then
  echo "No debian directories found. Exiting."
  exit 1
fi

success_count=0
fail_count=0
failure_tolerance=0.1  # Example: Allow up to 10% of modules to fail

for package_dir in $package_dirs; do
  if build_package "$package_dir"; then
    success_count=$((success_count + 1))
  else
    fail_count=$((fail_count + 1))
  fi

  # Check if failure tolerance is exceeded
  if [[ $(echo "scale=2; $fail_count / $total_modules" | bc) > $failure_tolerance ]]; then
    echo "Built $success_count packages successfully, but $fail_count failed out of $total_modules total packages."
    echo "Failure tolerance exceeded. Exiting build."
    exit 1
  fi
done

# Fix user IDs for output files
if [ -n "${OUTPUT_UID}" ]; then
   chown -R "${OUTPUT_UID}:${OUTPUT_UID}" "${OUTPUT}"/*
fi
