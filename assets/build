#!/usr/bin/env bash

# use exit codes of failing commands
set -exo pipefail

 # Ensure dpkg-deb always emits gzip-compressed control data to satisfy older reprepro
export DPKG_DEB="dpkg-deb -Zxz -z9 --uniform-compression"

# Set non-interactive frontend to avoid prompts during package installation
export DEBIAN_FRONTEND=noninteractive

SOURCES=${SOURCES-/sources}
OUTPUT=${OUTPUT-${SOURCES}}

# If a GitHub token is provided, configure netrc/curl for private source access
# Prefer GITHUB_TOKEN, then GITHUB_API_TOKEN, then LASTVERSION_GITHUB_API_TOKEN
GH_TOK="${GITHUB_TOKEN:-${GITHUB_API_TOKEN:-${LASTVERSION_GITHUB_API_TOKEN}}}"
echo "GitHub token detection: GITHUB_TOKEN=${GITHUB_TOKEN:+set} GITHUB_API_TOKEN=${GITHUB_API_TOKEN:+set} LASTVERSION_GITHUB_API_TOKEN=${LASTVERSION_GITHUB_API_TOKEN:+set} GH_TOK=${GH_TOK:+set}"
if [ -n "${GH_TOK}" ]; then
  echo "Configuring .netrc for GitHub private repo access..."
  # use restrictive umask only for writing secrets, then restore
  __OLD_UMASK=$(umask)
  umask 077
  cat > /root/.netrc <<EOF
machine github.com
  login x-access-token
  password ${GH_TOK}
machine codeload.github.com
  login x-access-token
  password ${GH_TOK}
EOF
  echo "--netrc" > /root/.curlrc
  umask "${__OLD_UMASK}"
  export GITHUB_API_TOKEN="${GITHUB_API_TOKEN:-${GH_TOK}}"
  export GITHUB_TOKEN="${GITHUB_TOKEN:-${GH_TOK}}"
fi

# Initialize default values for options and flags
FORCE=false
ENABLE_REPOS=""
EXTERNAL_BUILD_SCRIPT=""
NO_FETCH=false

# Store original arguments for checking --no-fetch
ORIGINAL_ARGS="$*"

# Loop through the arguments
while [[ "$1" != "" ]]; do
    case $1 in
        --force )
            FORCE=true
            ;;
        --enable-repos )
            shift # Move to the next argument, which should be the value for --option
            if [[ -n $1 ]]; then
                ENABLE_REPOS=$1
            else
                echo "Error: --enable-repos requires a value."
                exit 1
            fi
            ;;
        --external-build-script )
            shift # Move to the next argument, which should be the URL
            if [[ -n $1 ]]; then
                EXTERNAL_BUILD_SCRIPT=$1
            else
                echo "Error: --external-build-script requires a URL."
                exit 1
            fi
            ;;
        --no-fetch )
            NO_FETCH=true
            ;;
        * )
            echo "Invalid option: $1"
            exit 1
            ;;
    esac
    shift # Move to the next argument
done

# If external build script is specified, fetch and use it
if [[ -n "${EXTERNAL_BUILD_SCRIPT}" ]]; then
    echo "Fetching external build script from: ${EXTERNAL_BUILD_SCRIPT}"
    if curl -fsSL "${EXTERNAL_BUILD_SCRIPT}" > /tmp/external-build.sh; then
        chmod +x /tmp/external-build.sh
        exec /tmp/external-build.sh "$@"
    else
        echo "Failed to fetch external build script. Falling back to built-in script."
    fi
fi

# Try to fetch and execute the latest build script from GitHub
# This allows getting the latest build logic without rebuilding Docker images
# We add --no-fetch to prevent infinite recursion
if [[ "$NO_FETCH" != "true" ]]; then
    echo "Attempting to fetch latest build script from GitHub..."
    # Add cache busting to prevent GitHub from serving cached versions
    cache_buster=$(date +%s)
    if curl -fsSL "https://raw.githubusercontent.com/GetPageSpeed/debbuilder/refs/heads/main/assets/build?${cache_buster}" > /tmp/latest-build.sh; then
        chmod +x /tmp/latest-build.sh
        echo "Successfully fetched latest build script. Executing..."
        # Preserve original CLI arguments (e.g. --force) when delegating to the latest script
        exec /tmp/latest-build.sh --no-fetch ${ORIGINAL_ARGS}
    else
        echo "Failed to fetch latest build script. Using local version."
    fi
fi

# Enable additional repositories if needed
if [[ -n ${ENABLE_REPOS} ]]; then
  add-apt-repository "${ENABLE_REPOS}" || exit 1
  apt-get update
fi

# Look for all subdirectories containing a `debian` directory
find_packages() {
    find "${SOURCES}" -mindepth 1 -type d -name debian -print0 2>/dev/null | while IFS= read -r -d '' debian_dir; do
        local candidate
        candidate="$(dirname "${debian_dir}")"
        if [[ -f "${candidate}/upstream.yml" ]]; then
            echo "${candidate}"
        fi
    done
}

cleanup_tmpdir() {
    local dir="$1"
    if [[ -n "${dir}" && -d "${dir}" ]]; then
        rm -rf "${dir}"
    fi
}

# Ensure GetPageSpeed APT repo is configured so repo existence checks work.
# This mirrors the logic from repotest-deb/scripts/setup_repo.sh but is kept
# lightweight and idempotent for use inside build containers.
setup_getpagespeed_repo() {
    local channel="${1:-main}"

    # If repo is already configured, do nothing
    if [[ -f /etc/apt/sources.list.d/getpagespeed.list ]]; then
        return 0
    fi

    # Only Debian/Ubuntu are supported for this helper
    if [[ -f /etc/os-release ]]; then
        # shellcheck disable=SC1091
        . /etc/os-release
    else
        echo "setup_getpagespeed_repo: /etc/os-release missing; skipping GetPageSpeed repo setup."
        return 1
    fi

    local family="${ID:-}"
    local codename="${VERSION_CODENAME:-}"

    case "${family}" in
        debian|ubuntu) ;;
        *)
            echo "setup_getpagespeed_repo: unsupported OS family '${family}'; skipping."
            return 1
            ;;
    esac

    if [[ -z "${codename}" ]] && command -v lsb_release >/dev/null 2>&1; then
        codename="$(lsb_release -cs || true)"
    fi

    if [[ -z "${codename}" ]]; then
        echo "setup_getpagespeed_repo: unable to determine codename; skipping."
        return 1
    fi

    # Derive suite: codename or codename-mainline depending on channel
    local suite="${codename}"
    if [[ "${channel}" == "mainline" ]]; then
        suite="${codename}-mainline"
    fi

    echo "Configuring GetPageSpeed APT repo for ${family} ${suite} (channel=${channel})..."

    export DEBIAN_FRONTEND=noninteractive
    apt-get update -y || true
    apt-get install -y --no-install-recommends ca-certificates curl gnupg lsb-release || true

    mkdir -p /etc/apt/keyrings
    local keyring="/etc/apt/keyrings/getpagespeed.gpg"
    local gpg_url="${GPG_KEY_URL:-https://extras.getpagespeed.com/deb-archive-keyring.gpg}"

    if ! curl -fsSL "${gpg_url}" -o "${keyring}"; then
        echo "setup_getpagespeed_repo: failed to download ${gpg_url}; skipping repo setup."
        return 1
    fi

    chmod 0644 "${keyring}" || true

    local base_url="https://extras.getpagespeed.com/${family}"
    local list="/etc/apt/sources.list.d/getpagespeed.list"

    echo "deb [signed-by=${keyring}] ${base_url} ${suite} main" > "${list}"

    if ! apt-get update -y; then
        echo "setup_getpagespeed_repo: apt-get update failed after configuring GetPageSpeed repo; continuing without repo."
        return 1
    fi

    return 0
}

# Function to check if the package (name + version) already exists in the APT repo.
# This must run after debian/changelog is stamped so we can rely on dpkg-parsechangelog
# to return the exact version (including revisions/epochs set by packaging).
check_packages_in_repo() {
    local source_dir=$1
    cd "$source_dir"

    if [[ ! -f "debian/control" ]]; then
        echo "No debian/control in ${source_dir}; cannot check repo, will build."
        return 1
    fi

    if [[ ! -f "debian/changelog" ]]; then
        echo "No debian/changelog in ${source_dir}; cannot check repo, will build."
        return 1
    fi

    local package_version
    package_version="$(dpkg-parsechangelog --show-field Version 2>/dev/null || true)"
    if [[ -z "${package_version}" ]]; then
        echo "Unable to determine package version for ${source_dir}; will build."
        return 1
    fi

    # Derive package name from debian/control or fall back to directory name
    local package_name
    package_name="$(awk '/^Source:/{print $2; exit}' debian/control || true)"
    if [[ -z "${package_name}" ]]; then
        package_name="$(basename "$(pwd)")"
    fi

    # Determine distro and branch to compute the same REVISION we stamp later.
    if [[ -f /etc/os-release ]]; then
        # shellcheck disable=SC1091
        . /etc/os-release
        local os_id="${ID:-}"
        local os_version_id="${VERSION_ID:-}"
        if [[ -z "${os_id}" || -z "${os_version_id}" ]]; then
            echo "Missing OS metadata; cannot compute Debian revision. Will build."
            return 1
        fi
        if [[ "${os_id}" != "debian" && "${os_id}" != "ubuntu" ]]; then
            echo "Unsupported OS_ID '${os_id}'; will build."
            return 1
        fi

        local raw_branch="${GIT_BRANCH:-${CIRCLE_BRANCH:-${BRANCH:-}}}"
        local flavor
        if [[ "${raw_branch}" == "main" || "${raw_branch}" == "master" || -z "${raw_branch}" ]]; then
            # match build_package: main/master (or no branch) -> "stable"
            flavor="stable"
        else
            flavor="${raw_branch}"
        fi

        # Try to enable the public GetPageSpeed APT repo so apt-cache can see
        # already-published builds. Map flavor to channel: stable -> main,
        # anything containing "mainline" -> mainline, everything else -> main.
        local gps_channel="main"
        if [[ "${flavor}" == "mainline" || "${flavor}" == *"mainline"* ]]; then
            gps_channel="mainline"
        fi
        setup_getpagespeed_repo "${gps_channel}" || echo "Warning: GetPageSpeed APT repo not configured; repo existence checks may be incomplete."

        # Check if this exact version already exists in the configured APT repo
        if apt-cache show "${package_name}=${package_version}" 2>/dev/null | grep -q .; then
            echo "Package ${package_name} version ${package_version} already exists in APT repo. Skipping build."
            return 0
        else
            echo "Package ${package_name} version ${package_version} is missing in APT repo. Building it."
            return 1
        fi
    else
        echo "/etc/os-release not found; cannot determine distro for version suffix. Will build."
        return 1
    fi
}

# Build the debian package
build_package() {
    local source_dir=$1
    echo "Building package from directory: ${source_dir}"
    echo "Current directory before cd: $(pwd)"
    cd "$source_dir"
    echo "Current directory after cd: $(pwd)"

    if [[ ! -f "upstream.yml" ]]; then
        echo "Error: upstream.yml not found. This builder requires upstream.yml with 'version' and 'source'."
        return 1
    fi

    echo "Found upstream.yml; using it for upstream source resolution..."

    local PACKAGE=""
    if [[ -f "debian/control" ]]; then
        PACKAGE=$(awk '/^Source:/{print $2; exit}' debian/control || true)
    fi
    if [[ -z "${PACKAGE}" ]]; then
        PACKAGE=$(basename "$(pwd)")
    fi

    UPSTREAM_VERSION="$(awk -F\" '/^version:[[:space:]]*\"/{print $2; exit} /^version:[[:space:]]*[0-9]/{gsub(/^version:[[:space:]]*/,""); print; exit}' upstream.yml || true)"
    TEMPLATE="$(awk -F\" '/^source:[[:space:]]*\"/{print $2; exit} /^source:[[:space:]]*[^#]/{sub(/^source:[[:space:]]*/,""); gsub(/[[:space:]]+#.*/,""); print; exit}' upstream.yml || true)"
    if [[ -z "${UPSTREAM_VERSION}" ]] || [[ -z "${TEMPLATE}" ]]; then
        echo "Error: upstream.yml must define both version and source"
        return 1
    fi

    URL="${TEMPLATE//\{version\}/${UPSTREAM_VERSION}}"
    if printf '%s' "${URL}" | grep -q '{name}'; then
        URL="${URL//\{name\}/${PACKAGE}}"
    fi
    echo "Resolved source URL: ${URL}"

    local WORKDIR=""
    WORKDIR="$(mktemp -d -p "${TMPDIR:-/tmp}" debbuilder.XXXXXX)" || {
        echo "Error: failed to create temporary build directory."
        return 1
    }

    local FILENAME
    FILENAME="$(basename "${URL}")"
    local ARCHIVE_PATH="${WORKDIR}/${FILENAME}"

    echo "Downloading ${FILENAME}..."
    if ! curl -fsSL -o "${ARCHIVE_PATH}" "${URL}"; then
        echo "Error: failed to download ${URL}"
        cleanup_tmpdir "${WORKDIR}"
        return 1
    fi

    echo "Extracting ${FILENAME}..."
    if ! tar -xf "${ARCHIVE_PATH}" -C "${WORKDIR}"; then
        echo "Error: failed to extract ${ARCHIVE_PATH}"
        cleanup_tmpdir "${WORKDIR}"
        return 1
    fi

    local TOPDIR
    TOPDIR="$(tar -tf "${ARCHIVE_PATH}" | head -1 | cut -d/ -f1)"
    rm -f "${ARCHIVE_PATH}" || true

    local BUILD_ROOT="${WORKDIR}"
    if [[ -n "${TOPDIR}" && -d "${WORKDIR}/${TOPDIR}" ]]; then
        BUILD_ROOT="${WORKDIR}/${TOPDIR}"
    fi

    if [[ -d "${BUILD_ROOT}/${TOPDIR}" ]]; then
        mv "${BUILD_ROOT}/${TOPDIR}"/* "${BUILD_ROOT}/"
        rmdir "${BUILD_ROOT}/${TOPDIR}" || true
    fi

    if [[ ! -d "${BUILD_ROOT}/debian" ]]; then
        cp -r "${source_dir}/debian" "${BUILD_ROOT}/"
    fi

    if [[ -f "${source_dir}/version.yml" ]] && [[ ! -f "${BUILD_ROOT}/version.yml" ]]; then
        cp -f "${source_dir}/version.yml" "${BUILD_ROOT}/" || true
    fi

    cd "${BUILD_ROOT}"

    if [[ -f "version.yml" ]]; then
        echo "Found version.yml; fetching external module source..."
        # shellcheck disable=SC2015
        REPO="$(awk -F'\"' '/^repo:[[:space:]]*\"/{print $2; exit}' version.yml || true)"; [[ -z "${REPO}" ]] && REPO="$(awk -F': *' '/^repo:[[:space:]]*[^#]/{sub(/^repo:[[:space:]]*/,""); print; exit}' version.yml || true)"
        TAG="$(awk -F'\"' '/^tag:[[:space:]]*\"/{print $2; exit}' version.yml || true)"; [[ -z "${TAG}" ]] && TAG="$(awk -F': *' '/^tag:[[:space:]]*[^#]/{sub(/^tag:[[:space:]]*/,""); print; exit}' version.yml || true)"
        NAME="$(awk -F'\"' '/^upstream_name:[[:space:]]*\"/{print $2; exit}' version.yml || true)"; [[ -z "${NAME}" ]] && NAME="$(awk -F': *' '/^upstream_name:[[:space:]]*[^#]/{sub(/^upstream_name:[[:space:]]*/,""); print; exit}' version.yml || true)"
        if [[ -n "${REPO}" ]] && [[ -n "${TAG}" ]]; then
            [[ -z "${NAME}" ]] && NAME="$(basename "${REPO}")"
            URL_MODULE="https://github.com/${REPO}/archive/refs/tags/${TAG}.tar.gz"
            echo "Downloading module from ${URL_MODULE}"
            if curl -fsSL -o module.tgz "${URL_MODULE}"; then
                tar -xzf module.tgz
                rm -f module.tgz || true
                TAG_NOPREFIX="${TAG#v}"
                if [[ -d "${NAME}-${TAG}" ]] && [[ "${TAG}" != "${TAG_NOPREFIX}" ]] && [[ ! -d "${NAME}-${TAG_NOPREFIX}" ]]; then
                    mv "${NAME}-${TAG}" "${NAME}-${TAG_NOPREFIX}"
                fi
            else
                echo "Error: failed to download module from ${URL_MODULE}"
                cleanup_tmpdir "${WORKDIR}"
                return 1
            fi
        else
            echo "version.yml present but repo/tag missing; skipping external module fetch."
        fi
    fi

    # Check for upstream version if not set (read only from upstream.yml)
    if [[ -z "${UPSTREAM_VERSION}" ]] && [[ -f "upstream.yml" ]]; then
        UPSTREAM_VERSION="$(awk -F\" '/^version:[[:space:]]*\"/{print $2; exit} /^version:[[:space:]]*[0-9]/{gsub(/^version:[[:space:]]*/,""); print; exit}' upstream.yml || true)"
    fi

    if [[ -z "${UPSTREAM_VERSION}" ]]; then
        echo "Warning: No upstream version found; using existing changelog version."
    fi

    # Determine suite codename and compute Debian REVISION from /etc/os-release only
    if [[ -f /etc/os-release ]]; then
        # shellcheck disable=SC1091
        . /etc/os-release
        SUITE_CODENAME="${VERSION_CODENAME:-}"
        OS_ID="${ID:-}"
        OS_VERSION_ID="${VERSION_ID:-}"
        if [[ -z "${SUITE_CODENAME}" || -z "${OS_ID}" || -z "${OS_VERSION_ID}" ]]; then
            echo "Error: Missing fields in /etc/os-release (need VERSION_CODENAME, ID, VERSION_ID)."
            cleanup_tmpdir "${WORKDIR}"
            return 1
        fi
    else
        echo "Error: /etc/os-release not found; cannot determine suite and distro token."
        cleanup_tmpdir "${WORKDIR}"
        return 1
    fi

    # Compute distro token
    # - Debian: deb${VERSION_ID} (e.g., deb12)
    # - Ubuntu: ubuntu${VERSION_ID//./} (e.g., ubuntu2204)
    DISTRO_TOKEN=""
    if [[ "${OS_ID}" == "debian" ]]; then
        DISTRO_TOKEN="deb${OS_VERSION_ID}"
    elif [[ "${OS_ID}" == "ubuntu" ]]; then
        DISTRO_TOKEN="ubuntu${OS_VERSION_ID//./}"
    else
        echo "Error: Unsupported OS_ID '${OS_ID}'. Only debian/ubuntu are supported."
        cleanup_tmpdir "${WORKDIR}"
        return 1
    fi

    # Determine flavor based on branch env (GIT_BRANCH preferred)
    RAW_BRANCH="${GIT_BRANCH:-${CIRCLE_BRANCH:-${BRANCH:-}}}"
    if [[ -z "${RAW_BRANCH}" || "${RAW_BRANCH}" == "main" || "${RAW_BRANCH}" == "master" ]]; then
        FLAVOR="stable"
    else
        FLAVOR="${RAW_BRANCH}"
    fi

    # Compose Debian revision suffix (no release here; template controls -<release>~)
    # Example: gps1+deb12+mainline
    REVISION="gps1+${DISTRO_TOKEN}+${FLAVOR}"

    # Stamp debian/changelog:
    # - If changelog missing: create minimal templated changelog with placeholders, then stamp
    # - If placeholders present: replace VERSION, REVISION, SUITE_CODENAME
    # - Else: fallback to appending ~${SUITE_CODENAME} and set Distribution
    if [[ ! -f "debian/changelog" ]]; then
        echo "debian/changelog not found; generating minimal templated changelog."
        PACKAGE_NAME="$(dpkg-parsechangelog --show-field Source 2>/dev/null || true)"
        if [[ -z "${PACKAGE_NAME}" && -f "debian/control" ]]; then
            PACKAGE_NAME="$(awk '/^Source:/{print $2; exit}' debian/control || true)"
        fi
        if [[ -z "${PACKAGE_NAME}" ]]; then
            PACKAGE_NAME="$(basename "$(pwd)")"
        fi
        {
            echo "${PACKAGE_NAME} (VERSION-1~REVISION) SUITE_CODENAME; urgency=medium"
            echo
            echo "  * Automated build."
            echo
            echo " -- GetPageSpeed LLC <builder@getpagespeed.com>  $(date -R)"
        } > debian/changelog
    fi

    STAMPED=false
    if grep -qE 'VERSION|REVISION|SUITE_CODENAME' debian/changelog; then
        [[ -n "${UPSTREAM_VERSION}" ]] && sed -i "s/VERSION/${UPSTREAM_VERSION}/g" debian/changelog
        sed -i "s/REVISION/${REVISION}/g" debian/changelog
        sed -i "s/SUITE_CODENAME/${SUITE_CODENAME}/g" debian/changelog
        echo "Stamped debian/changelog with VERSION=${UPSTREAM_VERSION}, REVISION=${REVISION}, SUITE_CODENAME=${SUITE_CODENAME}"
        STAMPED=true
    fi

    # If debian/control uses VERSION as a placeholder anywhere
    # (e.g. Provides: nginx-rVERSION, Depends: foo-VERSION, etc.),
    # stamp it to the resolved upstream version so this logic is
    # reusable beyond nginx-specific packages.
    if [[ -n "${UPSTREAM_VERSION}" ]] && [[ -f "debian/control" ]] && grep -q "VERSION" debian/control; then
        sed -i "s/VERSION/${UPSTREAM_VERSION}/g" debian/control
        echo "Stamped debian/control with VERSION=${UPSTREAM_VERSION}"
    fi

    if [[ "${STAMPED}" != true ]]; then
        # Fallback path: per-suite suffixing and distribution set, without altering base version semantics
        current_version="$(dpkg-parsechangelog --show-field Version || true)"
        if [[ -n "${current_version}" ]]; then
            if [[ "${current_version}" == *"~${SUITE_CODENAME}"* ]]; then
                echo "Changelog already contains per-suite suffix ~${SUITE_CODENAME}"
                if command -v dch >/dev/null 2>&1; then
                    dch -D "${SUITE_CODENAME}" --force-distribution --no-auto-nmu -m "CI: set distribution to ${SUITE_CODENAME}" || true
                else
                    sed -i -E "1s/^(\S+ \()[^)]*(\) )(\S+)(; urgency=)/\1${current_version}\2${SUITE_CODENAME}\4/" debian/changelog || true
                fi
            else
                new_version="${current_version}~${SUITE_CODENAME}"
                echo "Updating changelog version: ${current_version} -> ${new_version} (distribution ${SUITE_CODENAME})"
                if command -v dch >/dev/null 2>&1; then
                    dch -v "${new_version}" --force-bad-version -D "${SUITE_CODENAME}" --force-distribution --no-auto-nmu -m "CI: per-suite suffix ~${SUITE_CODENAME}"
                else
                    sed -i -E "1s/^(\S+ \()([^)]*)(\) )/\1${new_version}\3/" debian/changelog
                    sed -i -E "1s/^(\S+ \([^)]*\) )(\S+)(; urgency=)/\1${SUITE_CODENAME}\3/" debian/changelog
                fi
            fi
        else
            echo "Warning: could not parse current changelog version; leaving changelog unmodified."
        fi
    fi

    if [ "$FORCE" = true ]; then
        echo "Building package without checking repository because --force is set"
    elif check_packages_in_repo "$(pwd)"; then
        echo "Skipping build for ${source_dir}."
        cleanup_tmpdir "${WORKDIR}"
        return 0
    fi

    # Clean up old build artifacts
    if [[ -f "debian/rules" ]]; then
        make -f debian/rules clean || dh clean || true
    fi

    # Ubuntu focal: downgrade debhelper compat level to 12 before resolving deps
    if [[ "${OS_ID}" == "ubuntu" && "${SUITE_CODENAME}" == "focal" ]]; then
        if [[ -f "debian/control" ]]; then
            if grep -qE 'debhelper-compat[[:space:]]*\(= *13\)' debian/control; then
                echo "Focal detected: rewriting debhelper-compat (= 13) -> (= 12) in debian/control"
                sed -i -E 's/debhelper-compat[[:space:]]*\(= *13\)/debhelper-compat (= 12)/g' debian/control
            fi
            if grep -qE 'debhelper[[:space:]]*\(>= *13' debian/control; then
                echo "Focal detected: rewriting debhelper (>= 13) -> (>= 12) in debian/control"
                sed -i -E 's/debhelper[[:space:]]*\(>= *13/debhelper (>= 12/g' debian/control
            fi
        fi
        if [[ -f "debian/compat" ]]; then
            if grep -q '^13$' debian/compat; then
                echo "Focal detected: rewriting debian/compat 13 -> 12"
                echo "12" > debian/compat
            fi
        fi
    fi

    # Install build dependencies from the current directory (which should have debian/control)
    echo "Installing build dependencies from $(pwd)..."

    # Ensure package lists are up to date
    echo "Updating package lists..."
    if ! apt-get update; then
        echo "Warning: Failed to update package lists, attempting to fix repository configuration..."
        # Universal approach: Try to fix GPG issues without hardcoding distros
        echo "Attempting to fix GPG key issues..."
        # Method 1: Try updating with --allow-unauthenticated
        if apt-get update --allow-unauthenticated; then
            echo "Successfully updated package lists with --allow-unauthenticated"
        else
            echo "Failed with --allow-unauthenticated, trying to fix GPG keys..."

            # Method 2: Try to refresh GPG keys
            if command -v apt-key &>/dev/null; then
                echo "Refreshing GPG keys..."
                apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 648ACFD622F3D138 || true
                apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 0E98404D386FA1D9 || true
                apt-key adv --keyserver keyserver.ubuntu.com --recv-keys DCC9EFBF77E11517 || true
            fi

            # Method 3: Try updating with trusted repositories
            if ! apt-get update --allow-unauthenticated; then
                echo "Attempting to configure trusted repositories..."

                # Backup current sources
                cp /etc/apt/sources.list /etc/apt/sources.list.backup 2>/dev/null || true

                # Try to detect the distribution dynamically
                if [[ -f /etc/os-release ]]; then
                    source /etc/os-release
                    DISTRO_NAME="${VERSION_CODENAME:-${ID}}"
                    echo "Detected distribution: $DISTRO_NAME"
                elif [[ -f /etc/debian_version ]]; then
                    # Fallback for older Debian systems - only use known versions
                    DEBIAN_VERSION=$(cat /etc/debian_version | cut -d. -f1)
                    case $DEBIAN_VERSION in
                        12) DISTRO_NAME="bookworm" ;;
                        13) DISTRO_NAME="trixie" ;;
                        *)
                            echo "Error: Unknown Debian version $DEBIAN_VERSION. Cannot safely determine repository."
                            echo "Please ensure /etc/os-release is available or update this script for new Debian versions."
                            cleanup_tmpdir "${WORKDIR}"
                            return 1
                            ;;
                    esac
                    echo "Detected Debian version: $DEBIAN_VERSION -> $DISTRO_NAME"
                else
                    echo "Error: Could not detect distribution"
                    echo "Neither /etc/os-release nor /etc/debian_version found."
                    cleanup_tmpdir "${WORKDIR}"
                    return 1
                fi

                # Create a minimal trusted sources.list
                cat > /etc/apt/sources.list << EOF
deb [trusted=yes] http://deb.debian.org/debian $DISTRO_NAME main
deb [trusted=yes] http://deb.debian.org/debian $DISTRO_NAME-updates main
deb [trusted=yes] http://deb.debian.org/debian-security $DISTRO_NAME-security main
EOF

                # Try updating with the new configuration
                if ! apt-get update --allow-unauthenticated; then
                    echo "Error: Failed to update package lists even after reconfiguring repositories"
                    echo "Restoring original sources.list..."
                    cp /etc/apt/sources.list.backup /etc/apt/sources.list 2>/dev/null || true
                    cleanup_tmpdir "${WORKDIR}"
                    return 1
                fi
            fi
        fi
    fi

    # Pre-configure timezone to avoid tzdata interactive prompts
    echo "tzdata tzdata/Areas select Etc" | debconf-set-selections
    echo "tzdata tzdata/Zones/Etc select UTC" | debconf-set-selections
    # Also set the timezone directly
    ln -sf /usr/share/zoneinfo/Etc/UTC /etc/localtime
    echo "Etc/UTC" > /etc/timezone

    # Check for missing dependencies first
    if [[ -f "/usr/bin/check-deps.sh" ]]; then
        echo "Checking build dependencies..."
        # Ensure the script has execute permissions
        chmod +x /usr/bin/check-deps.sh || true
        /usr/bin/check-deps.sh || {
            echo "Dependency check failed. Attempting to install anyway..."
        }
    fi

    # Preferred: install Build-Depends from local debian/control via mk-build-deps
    if [[ -f "debian/control" ]]; then
        echo "Attempting to install Build-Depends via mk-build-deps..."
        if mk-build-deps -t 'apt-get --no-install-recommends -y' -i -r debian/control; then
            echo "Successfully installed Build-Depends via mk-build-deps."
        else
            echo "mk-build-deps failed; attempting apt-get build-dep and manual fallback..."
            # Try apt-get build-dep on the local tree
            if apt-get build-dep -y .; then
                echo "Successfully installed build dependencies via apt-get build-dep."
            elif apt-get build-dep -y --allow-unauthenticated .; then
                echo "Successfully installed build dependencies with --allow-unauthenticated."
            else
                echo "Falling back to parsing Build-Depends from debian/control..."
                # Parse Build-Depends (first stanza) into package names (drop versions and alternatives)
                RAW_DEPS=$(awk '/^Build-Depends:/ {flag=1; sub(/^Build-Depends:[[:space:]]*/,""); print; next} /^[^ ]/ {flag=0} flag {print}' debian/control \
                    | tr -d '\n' | sed 's/, */\n/g' | sed 's/ (.*)//g' | sed 's/|/ /g' | awk '{print $1}' | grep -v -E '^[[:space:]]*$' || true)
                if [[ -n "${RAW_DEPS}" ]]; then
                    echo "Installing parsed Build-Depends: ${RAW_DEPS}"
                    if ! apt-get install -y --no-install-recommends ${RAW_DEPS}; then
                        echo "Warning: direct install of parsed Build-Depends failed; continuing."
                    fi
                fi
                # Heuristic: common C toolchain deps (useful for C/C++ projects like nginx)
                apt-get install -y --no-install-recommends build-essential || true
            fi
        fi
    else
        echo "No debian/control found; skipping mk-build-deps."
    fi

    # Build the package
    debuild -us -uc -b || {
        echo "Failed to build ${source_dir}."
        cleanup_tmpdir "${WORKDIR}"
        return 1
    }

    # Move built packages to output directory
    mkdir -p "${OUTPUT}"
    mv ../*.deb "${OUTPUT}/"
    # Include Ubuntu debug packages (.ddeb) if present
    mv ../*.ddeb "${OUTPUT}/" 2>/dev/null || true
    mv ../*.buildinfo "${OUTPUT}/"
    mv ../*.changes "${OUTPUT}/"

    # Rename packages to include distribution if DISTRO is set
    if [[ -n "${DISTRO}" ]]; then
        cd "${OUTPUT}"
        for deb in *.deb; do
            if [[ -f "$deb" ]]; then
                # Extract current version from the deb filename
                current_version=$(echo "$deb" | sed -n 's/.*_\([0-9]\+\.[0-9]\+\.[0-9]\+\)-[0-9]_.*/\1/p')
                if [[ -n "$current_version" ]]; then
                    newname=$(echo "$deb" | sed "s/_${current_version}-[0-9]_/_${current_version}-1.${DISTRO}_/")
                    if [[ "$deb" != "$newname" ]]; then
                        mv "$deb" "$newname"
                        echo "Renamed: $deb -> $newname"
                    fi
                fi
            fi
        done
    fi

    cleanup_tmpdir "${WORKDIR}"

    echo "Package built successfully for ${source_dir}."
}

# Find all packages and build them
echo "SOURCES directory: ${SOURCES}"
echo "Contents of SOURCES:"
ls -la "${SOURCES}" || echo "Cannot list SOURCES directory"

package_dirs=$(find_packages)

echo "Found package directories:"
echo "$package_dirs"

total_modules=$(echo "$package_dirs" | wc -l)
if [[ "$total_modules" -eq 0 ]]; then
  echo "No debian directories found. Exiting."
  exit 1
fi

success_count=0
fail_count=0
failure_tolerance=0.1  # Example: Allow up to 10% of modules to fail

for package_dir in $package_dirs; do
  if build_package "$package_dir"; then
    success_count=$((success_count + 1))
  else
    fail_count=$((fail_count + 1))
  fi

  # Check if failure tolerance is exceeded
  if [[ $(echo "scale=2; $fail_count / $total_modules" | bc) > $failure_tolerance ]]; then
    echo "Built $success_count packages successfully, but $fail_count failed out of $total_modules total packages."
    echo "Failure tolerance exceeded. Exiting build."
    exit 1
  fi
done

# Fix user IDs for output files
if [ -n "${OUTPUT_UID}" ]; then
   chown -R "${OUTPUT_UID}:${OUTPUT_UID}" "${OUTPUT}"/*
fi
